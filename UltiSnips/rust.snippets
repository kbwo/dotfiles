snippet s_pub_struct "pub struct $1 {"
#[derive(Debug, $1)]
pub struct $2 {
}
endsnippet
snippet s_fn "fn name(?) -> ? {}"
fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet s_pubfn "pub fn name(?) -> ? {}"
pub fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet s_asyncfn "async fn name(?) -> ? {}"
async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet s_pubasyncfn "pub async fn name(?) -> ? {}"
pub async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet s_print "print!(..)"
print!("$1"${2/..*/, /}$2);
endsnippet

snippet s_println "println!(..)"
println!("$1"${2/..*/, /}$2);
endsnippet

snippet s_format "format!(..)"
format!("$1"${2/..*/, /}$2);
endsnippet

snippet s_dbg! "dbg!(..)"
dbg!("$1");
endsnippet

snippet s_impl "Struct/Trait implementation"
impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {
	${0}
}
endsnippet

snippet s_assert_eq "assert"
assert_eq!(${1:Target}, ${2: Value});
endsnippet

snippet s_match "match ... (match)"
match ${1:expression} {
	${2:pattern} => ${3:expression},
	${4:pattern} => ${5:expression},
	${VISUAL}${6:${VISUAL/(.*)/_/}} => ${0:expression},
}
endsnippet

snippet s_while "while ... (while)"
while ${1:condition} {
	${0}
}
endsnippet

snippet s_modtest "mod tests {..."
#[cfg(test)]
mod tests {

    #[test]
    fn $1() {
    }

}
endsnippet

snippet s_args "let args: Vec<String> = std::env::args().collect();..."
let args: Vec<String> = std::env::args().collect();
if args.len() >= $1 {
		panic!("unexpected number of arguments");
}
endsnippet

snippet s_reas_file_to_string "read file to string buffer"
let mut buf = String::new();
${1:AsRef<Path>}.as_ref().reas_to_string(buf);
endsnippet

snippet s_filepath_type "AsRef<Path>>"
AsRef<Path>
endsnippet

snippet s_file_metadata_stat "fs::metadata(filename)"
fs::metadata("$1")
endsnippet

snippet s_io_result "io::Result" 
io::Result<$1, $2>
endsnippet

snippet s_mkdir "fs::create_dir" 
fs::create_dir("$1")
endsnippet

snippet s_threas_spawn "thread::spawn(move || {..."
thread::spawn(move || {
	$1
});
endsnippet

snippet s_actix_server_init "HttpServer::new(move || {"
HttpServer::new(move || {
	App::new()
		.wrap(${1:middleware})
		.app_data(${2:Data})
		.configure(|cfg| ${3:config_fn})
})
.bind(${4:net::ToSocketAddrs})?
.run()
.await?;
endsnippet

snippet s_actix_route_config_init "pub fn config(cfg: &mut web::ServiceConfig) {..."
pub fn config(cfg: &mut web::ServiceConfig) {
  cfg
    .route("/", web::get().to(${1:fn}))

  cfg.service(
    web::scope("")
      .wrap(${2:middleware})
      .guard(${3:guard})
      .route("", web::post().to())
  );
}
endsnippet

snippet s_actix_response_impl_responder "async fn $1() -> impl Responder {..."
#[$1("$2")]
async fn $3() -> impl Responder {
    HttpResponse::Ok().json(/* */)
}
endsnippet

snippet s_actix_response_result "async fn $1() -> impl Responder {..."
#[$1("$2")]
async fn $3() -> Result<HttpResponse, $4> {
    HttpResponse::Ok().json(/* */)
}
endsnippet

snippet s_actix_form_type "actix form type"
Form<$1>
endsnippet

snippet s_environment_variable "let log_description = std::env::var..."
let $1 = std::env::var("${2:env_name}").unwrap_or_else(|_| "$3".into());
endsnippet

snippet s_tracing_subscriber_init "let layer = tracing_subscriber::fmt::layer()..." 
let layer = tracing_subscriber::fmt::layer().with_filter(targets.clone());

let subscriber = Registry::default()
	.with(layer)
	.with(ErrorLayer::default());
endsnippet

snippet s_tracing_set_global_default "set global default subscriber" 
set_global_default(subscriber);
endsnippet

snippet s_tracing_instrument_fields "#[tracing::instrument(fields(additional_field))]"
#[tracing::instrument(fields($1))]"
endsnippet

snippet s_tracing_instrument_skip_all "#[tracing::instrument(skip_all)]"
#[tracing::instrument(skip_all)]"
endsnippet

snippet s_tracing_instrument_skip "#[tracing::instrument(skip(field))]"
#[tracing::instrument(skip($1))]"
endsnippet

snippet s_duration_fromsecs "Duration::from_secs()"
Duration::from_secs($1)
endsnippet

snippet s_pub_crate "pub for current crate"
pub(crate)
endsnippet

snippet s_pub_self "pub for current module"
pub(self)
endsnippet

snippet s_pub_path "pub for specific path"
pub(in $1)
endsnippet

snippet s_pub_super "pub for parent"
pub(super)
endsnippet

snippet s_hashmap_type "typeof hashmap"
HashMap<${1:key}, ${2:value}>
endsnippet

snippet s_hashset_type "typeof hashset"
HashSet<${1:key}>
endsnippet

snippet s_threadlocal_random_generator "rand::thread_rng()"
rand::thread_rng()
endsnippet

snippet s_hashmap_mut_iter_method ".values_mut()"
${1:HashMap}.values_mut()
endsnippet

snippet s_future_callback_return_types "Pin<Box<dyn Future<Output = Result<$1, $2>> + '_>>"
Pin<Box<dyn Future<Output = Result<$1, $2>> + '_>>
endsnippet

snippet s_let_if_ok "if let Ok($1) = $2 {"
if let Ok($1) = $2 {
}
endsnippet

snippet s_async_trait "#[async_trait::async_trait(?Send)]"
#[async_trait::async_trait(?Send)]
endsnippet

snippet s_custom_error_with_inner ""
struct Error {
  message: Option<String>,
  inner: ${1:anyhow::Error},
  context: $2,
}
endsnippet

snippet s_macro_use "#[macro_use]"
#[macro_use]
endsnippet

snippet s_thread_builder "thread::Builder::new()..."
thread::Builder::new()
    .name("$1".into())
    .spawn(move || {
        $2
    })
    .expect("$3");
endsnippet

snippet s_tokio_main "#[tokio::main]"
#[tokio::main]
endsnippet

snippet s_byte_to_utf8_string "str::from_utf8().unwrap()"
str::from_utf8($1).unwrap()
endsnippet

snippet s_thiserror_enum "Description" 
#[derive(thiserror::Error, Debug)]
pub enum $1 {
    #[error("$2")]
    $3(#[from] $4),
}
endsnippet
